#pragma config(Sensor, dgtl1,  S_sensor_in,    sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  middle_bump,    sensorTouch)
#pragma config(Sensor, dgtl5,  nose_bump,      sensorTouch)
#pragma config(Sensor, dgtl8,  front_left_bump, sensorTouch)
#pragma config(Sensor, dgtl10, back_left_bump, sensorTouch)
#pragma config(Sensor, dgtl12, back_bump,      sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void left_wall();

void turn_bot(int degree){ // rotates the robot according to parameter degree
	int delay = 950; //delay is ms to execute a 90deg turn
	int mov_angle = degree - 90; // how much does the angle differ from 90
	// 180 - 90 = 90 degree CCW turn, 0 - 90 = -90 degree CW turn
	float scale = 90;
	delay = (abs(mov_angle)/scale) * delay; //scales the delay to the degrees to turn

	if(mov_angle<-3){  // turn CW
		motor[rightMotor] = 50;
		motor[leftMotor] = 50;
		wait1Msec(delay); // scaled delay
		motor[rightMotor] = 0; // stop
		motor[leftMotor] = 0;
	}
	else if(mov_angle>3){ // turn CCW
		motor[rightMotor] = -50;
		motor[leftMotor] = -50;
		wait1Msec(delay); // scaled delay
		motor[rightMotor] = 0; // stop
		motor[leftMotor] = 0;
	}
}

void drive_left(int delay){ //drives forward for "delay" milliseconds
	// higher value for right motor so robot
	// is always curving to the left
	motor[rightMotor] = -107;
	motor[leftMotor] = 80;
	wait1Msec(delay);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void backup_right(){
	motor[rightMotor] = 107;
	motor[leftMotor] = -70; //backs up
	wait1Msec(600);
	motor[rightMotor] = -10; //turns slightly right away from wall
	motor[leftMotor] = 127;
	wait1Msec(750);
	turn_bot(65); // turn CW 25 degrees
}

int hit_front(){
	// if any of the front sensors are pressed, backup. returns 1 (true)
	if (SensorValue[nose_bump] == 1 || SensorValue[back_bump] == 1 || SensorValue[middle_bump] == 1){
		backup_right(); //back up, turn CW
		return 1; 
	}
	// else return 0 (false)
	return 0;
}

void left_wall(){
	hit_front(); //inital checking for obstacle avoidance measures

	// if both side limit switches are pressed, move forward
	while(SensorValue[front_left_bump] == 1 && SensorValue[back_left_bump] == 1){
		drive_left(125); // drive forward
		if (hit_front()) break; // if you hit an obstacle, break
	}
	if (SensorValue[S_sensor_in] > 30){ // if further than 30 cm away from the wall
		//lost wall so keep moving forward, until back bumper loses contact
		while(SensorValue[back_left_bump] == 1){
			drive_left(125);
		}
		drive_left(500); //scoot forward to clear walls
		if (hit_front()) break; // if trapped in a corner, break
		turn_bot(180); // turn 90 degrees CCW
		//scaled to estimate distance to re-engage wall
		drive_left(30*SensorValue[S_sensor_in]);
	}
	else{ // if sensor <= 30 cm
		//still near wall, let's follow it!
		for(int i=0; i<12; i++){ // 12 iterations
			drive_left(100); // move forward
			if(hit_front()) break; // check for obstacles!
			if (SensorValue[S_sensor_in] > 45) break; // you lost the wall :(
		}
	}
	left_wall(); // recursive calling 
}

task main()
{
	drive_left(200); // drive forward out the gates
	left_wall(); // workhorse wall-following algorithm 
}
