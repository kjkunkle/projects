#pragma config(Sensor, in1,    shoulder_pot,   sensorPotentiometer)
#pragma config(Sensor, in2,    elbow_pot,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  front_limit,    sensorTouch)
#pragma config(Sensor, dgtl2,  back_limit,     sensorTouch)
#pragma config(Sensor, dgtl9,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           center_motor,  tmotorVex393, openLoop)
#pragma config(Motor,  port3,           shoulder_motor, tmotorVex393, openLoop)
#pragma config(Motor,  port4,           elbow_motor,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           claw_servo,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float shoulder_pot_angle();
float elbow_pot_angle();
void release_claw();
void reset();

float shoulder_y(){ // sin(x) = opposite/hyp
	return sinDegrees(shoulder_pot_angle() - 90.0)*34;
}

float shoulder_x(){ // uses pythagorean theorem
	float y = shoulder_y();
	return sqrt(pow(34,2) - pow(y,2));
}

float elbow_angle_reference(){ // p
	return 180.0 - shoulder_pot_angle();
}

float elbow_angle_prime(){ // e'
	return elbow_pot_angle() - elbow_angle_reference();
}

float elbow_hyp(){ // C, uses law of cosines
	return sqrt(pow(shoulder_y(),2) + pow(37.5,2) - shoulder_y()*37.5*cosDegrees(elbow_angle_prime()));
}

float elbow_y_opp_angle(){ // angle that is opposite from elbow's y
	// n = 90 - m
	// uses law of sines to find m
	return 90 - radiansToDegrees(asin(37.5*sinDegrees(elbow_angle_prime())/elbow_hyp()));
}

float elbow_y(){ // uses sin(x) = opp/hyp
	return elbow_hyp()*sinDegrees(elbow_y_opp_angle());
}

float elbow_x(){ // uses pythagorean theorem
	return sqrt(pow(elbow_hyp(), 2) - pow(elbow_y(), 2)) + shoulder_x();
}

float elbow_pot_angle(){ // e
	return 0.0596*SensorValue[elbow_pot] + 66.889;
}

float shoulder_pot_angle(){ // s
	return -0.0626*SensorValue[shoulder_pot] + 210.51;
}

// Sets the shoulder extension to inputted angle
void set_sho(int angle){
	int cur_sho = round(shoulder_pot_angle());
	while(cur_sho != angle){
		while(cur_sho > angle){
			motor[shoulder_motor] = -30;
			cur_sho = round(shoulder_pot_angle());
			if(cur_sho < angle-5) break;
			}
		while(cur_sho < angle){
			motor[shoulder_motor] = 30;
			cur_sho = round(shoulder_pot_angle());
			if(cur_sho > angle+5) break;
		}
			motor[shoulder_motor] = 0;
	}
}

//rotates the crane 180 degrees CW
//drops the object onto the target
//rotates 180 degrees CCW back to starting position
void rotate_and_drop(){
	//rotate CW
	writeDebugStreamLine("Moving CW");
	motor[center_motor] = -36;
	wait1Msec(800);
	motor[center_motor] = 0;
	wait1Msec(3000);

	//Drop can
	release_claw();

	//Rotate CCW
	writeDebugStreamLine("Moving CCW");
	while(true){
		motor[center_motor] = 67;
		if(SensorValue[front_limit]){
			motor[center_motor] = 60;
			wait1Msec(800);
  		break;
		}
  }
  motor[center_motor] = 20;
  wait1Msec(3000);
  motor[center_motor] = 0;
}

// Sets the elbow extension to inputted angle
void set_elb(int angle){
	int cur_elb = round(elbow_pot_angle());
	while(cur_elb != angle){
		while(cur_elb > angle){
			motor[elbow_motor] = -30;
			cur_elb = round(elbow_pot_angle());
			if(cur_elb < angle-5) break;
			}
		while(cur_elb < angle){
			motor[elbow_motor] = 30;
			cur_elb = round(elbow_pot_angle());
			if(cur_elb > angle+5) break;
		}
			motor[elbow_motor] = 0;
	}
}

void reset(int shoulder, int elbow){
	//set shoulder to 130 and elbow to 125
	int cur_elb = round(elbow_pot_angle());
	int cur_sho = round(shoulder_pot_angle());

	while (cur_sho<135){
		set_sho(cur_sho+3);
		if (cur_elb <180){
			set_elb(cur_elb+1);
		}
		cur_sho = round(shoulder_pot_angle());
		cur_elb = round(elbow_pot_angle());
	}
	while (cur_sho>135){
		set_sho(cur_sho-3);
		if (cur_elb <180){
			set_elb(cur_elb+1);
		}
		cur_sho = round(shoulder_pot_angle());
		cur_elb = round(elbow_pot_angle());
	}
	set_sho(shoulder);
	set_elb(elbow);
	set_sho(135);
	set_elb(115);
}

// grabs an object with the claw
void grab_claw(){
	motor[claw_servo] = 127;
	wait1Msec(3000);
}

// releases an object with the claw
void release_claw(){
	motor[claw_servo] = -127;
	wait1Msec(3000);
}

//lift the can slightly off of the ground so rotation can begin
void lift_can(){
	int cur_elb = round(elbow_pot_angle());
	int cur_sho = round(shoulder_pot_angle());

	set_sho(cur_sho + 3);
}

// lowers the elbow so that the claw is in place to grab the object
void lower_elbow_new(int dist){
	int cur_elb = round(elbow_pot_angle());
	int cur_sho = round(shoulder_pot_angle());

	while (cur_sho>96){
		writeDebugStreamLine("loop %d", SensorValue[sonar]+28);
		set_sho(cur_sho-1);
		set_elb(cur_elb);
		cur_sho = round(shoulder_pot_angle());
		int val = SensorValue[sonar]+28;
		if (val < dist - 1 || val > dist + 1){
			writeDebugStreamLine("break %d", val);
			break;
		}
	}
		set_sho(cur_sho-5);
		cur_sho = round(shoulder_pot_angle());
		if (cur_sho <= 96){
			set_elb(178);
		}else{
			cur_elb = round(elbow_pot_angle());
			if (dist <64){
					//dont re-position
			}else{
				set_elb(cur_elb-1);
			}
			set_sho(cur_sho-3);
		}
		if(dist >= 69){
			cur_elb = round(elbow_pot_angle());
			set_elb(cur_elb-3);
	  }
		writeDebugStreamLine("lowered\n");
}

// extends the arm so that it is directly over the specified distance
void ang_extend(int dist){
	dist = dist;
	int cur_dist = elbow_x();
	while (cur_dist < dist-2){
		writeDebugStreamLine("Elbow X: %f", elbow_x());
		int cur_elb = round(elbow_pot_angle());
		int cur_sho = round(shoulder_pot_angle());
		if (cur_sho < 96) break;

		set_sho(cur_sho - 2);
		cur_dist = elbow_x();
		cur_elb = round(elbow_pot_angle());
		if (cur_dist > dist) break;
		if (cur_elb>= 180){
			set_elb(cur_elb - 2);
		}else{
			set_elb(cur_elb + 2);
		}
		cur_dist = elbow_x();
	}
	while (cur_dist > dist + 5){
		int cur_elb = round(elbow_pot_angle());
		int cur_sho = round(shoulder_pot_angle());
		if (cur_elb>= 180){
			set_elb(cur_elb + 2);
		}else{
			set_elb(cur_elb - 2);
		}
		cur_dist = elbow_x();
		cur_elb = round(elbow_pot_angle());
		if (cur_dist < dist) break;
		set_sho(cur_sho + 4);
		cur_dist = elbow_x();
	}
	writeDebugStreamLine("Elbow X: %f", elbow_x());
	writeDebugStreamLine("Extended over can.");
}

task main()
{
	while(true){
		bool in_range = true; // is the object in range
		// Reset to starting arm configuration
		reset(135, 115);
		release_claw();
		writeDebugStreamLine("Reset.");

		// continue reading until there is no error
		int can = -1;
		while(can == -1){
			can = SensorValue[sonar];
		}
		// add 28 cm to account for the sonar being 28 cm away from the crane base
		can = can + 28;
		writeDebugStreamLine("Can distance: %d", can);

		//Total range = 54 cm - 72 cm
		// 60 cm - 72 cm range uses angle_extend() function
		if (can>=60 && can<72){
			ang_extend(can);
			wait10Msec(25);
			lower_elbow_new(can);
		}
		// 54 cm - 59 cm range uses reset_short function
		else if (can >= 54 && can < 60){
			// reset retracts the arm here
			reset(135, 108);
			if (can>57){
				set_sho(round(shoulder_pot_angle())+1);
			}
			wait10Msec(25);
		}
		else{
			writeDebugStreamLine("Out of range.");
			in_range = false;
		}
		// only grab and drop if in range
		if(in_range){
			grab_claw();
			lift_can();
			writeDebugStreamLine("Lifted object.");
			rotate_and_drop();
		}
	}
}
