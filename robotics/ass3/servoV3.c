// PART 3
#pragma config(Sensor, in1,    L_sensor,       sensorReflection)
#pragma config(Sensor, in2,    Pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl9,  sSONAR,         sensorSONAR_cm)
#pragma config(Sensor, dgtl11, Bump1,          sensorNone)
#pragma config(Sensor, dgtl12, Bump2,          sensorNone)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port6,           Servo,         tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float pot_angle();
int searchLight();
void drive();


int searchLight(){
	int MaxLight = 1123; // max darkness
	int templight; // temporary value used for coping
	int MaxAngle;  // angle value of sensor where maximum brightness has been found
	int servo_pos = -127; // initial servo position

	motor[Servo] = -127; // set initial servo position - all the way clockwise
	wait1Msec(400);

	while(servo_pos<=127){ // 128 iterations in steps of 2
		//writeDebugStreamLine("%d\n", servo_pos);
		motor[Servo] = servo_pos; // set servo to the next position 
		wait1Msec(10); // give it time to move
		templight = SensorValue[L_sensor]; // store value of light

		if (templight<MaxLight){ // if brighter light found
			MaxLight = templight; // update max brightness found
			MaxAngle = servo_pos; // update angle of max brightness
		}
		servo_pos=servo_pos+2; // +2 rotation values in counter clockwise direction
	}

	motor[Servo] = MaxAngle; // point back to brightest direction
	wait1Msec(500); // wait for movement
	return pot_angle();
	//return MaxAngle;
}

float pot_angle(){ //calculates the angle based on current pot reading
	float reading;
	float angle;

	reading = SensorValue[Pot]; // current pot reading 
	angle = -0.0577*(reading) + 163.33; // calibration function
	return angle; // return actual physical angle
}

void turn_bot(int degree){
	int delay = 500; //delay is  ms to execute a 90deg turn
	int mov_angle = degree - 90; // how much does the angle differ from 90

	float scale = 90;

	delay = (abs(mov_angle)/scale) * 500; //scales the delay to the degrees to turn

	if(mov_angle<-3){  // turn CCW
		motor[rightMotor] = 49; 
		motor[leftMotor] = 49;
		wait1Msec(delay); // scaled delay
		motor[rightMotor] = 0; // stop
		motor[leftMotor] = 0;
	}
	else if(mov_angle>3){ // turn CW
		motor[rightMotor] = -49;
		motor[leftMotor] = -49;
		wait1Msec(delay); // scaled delay
		motor[rightMotor] = 0; // stop
		motor[leftMotor] = 0;
	}
}

void drive(){
	int dist = 20;
	int sonar = SensorValue(sSONAR); //store current value of sonar sensor
	int bumper_value1 = SensorValue(Bump1);
	int bumper_value2 = SensorValue(Bump2);

    int i = 0;
    // if no object sensed, move forward
    if(sonar>dist && bumper_value1 == 1 && bumper_value2 == 1){
    	while(sonar > dist && i < 3){ // 3 seconds of movement if no obstacles
    		motor[leftMotor] = 50; //go forwards
	    	motor[rightMotor] = -50; //go forwards
	    	wait1Msec(1000);  // move forwards for 1 sec
	    	motor[leftMotor] = 0; //stop
	    	motor[rightMotor] = 0;
	    	sonar = SensorValue(sSONAR); // reassign sensors
	    	bumper_value1 = SensorValue(Bump1);
			bumper_value2 = SensorValue(Bump2);
	    	i++;
	    	// if object sensed, break
	    	if(!(sonar>dist && bumper_value1 == 1 && bumper_value2 == 1)){
	    		break; 
	    	}
	  	}
	}
	//if object sensed, backup and attempt to avoid or go around obstacle 
	if (!(sonar>dist && bumper_value1 == 1 && bumper_value2 == 1){ 
	    motor[leftMotor] = -50; //go backwards
	    motor[rightMotor] = 50; //go backwards
	    wait1Msec(1000);
	    motor[rightMotor] = -49; // swerve
		motor[leftMotor] = -49;	 // aka rotate CW
		wait1Msec(250);
	    motor[leftMotor] = 0; //stop
	    motor[rightMotor] = 0;
    }
}


task main()
{
	wait1Msec(2000);
	int angle;	// actual physical angle
	while(true){ // loop forever
		wait1Msec(1000);
		angle = searchLight(); // return brightest angle
		//writeDebugStreamLine("%d\n",angle);
		if(angle < 87 | angle > 93){
			turn_bot(angle);
		}
		else{
			drive();
		}
	}
}
